# Практики разработки (NCFG)

Этот документ описывает практические правила для проекта: как раскладывать код по слоям (Adapted FSD), как оформлять компоненты/модули, куда выносить константы и конфиг, как именовать сущности и что считать “нормой” в TypeScript + Next.js.

Смежные документы:
- Git/PR/коммиты: `CONTRIBUTING.md`
- Архитектура фронтенда (FSD подробно): `apps/web/ARCHITECTURE.md`

## 0) Общие принципы

- Предпочитаем маленькие, обозримые PR: одна логическая задача = один PR.
- Перед тем как “сделать по‑своему” — посмотрите как уже сделано в репозитории и продолжайте существующий паттерн.
- UI-текст: простой русский (короткие предложения). Код/идентификаторы: английский.

## 1) Каркас проекта

Основной код:
- `apps/web` — Next.js (App Router), React, TypeScript, Tailwind
- `apps/cms` — Strapi CMS

## 2) Архитектура фронтенда: Adapted FSD

Слои (сверху вниз):
```
apps/web/app        # роутинг Next.js, компоновка страниц
apps/web/widgets    # секции страниц (собирают сущности/фичи в блоки)
apps/web/features   # пользовательские действия (может отсутствовать сейчас)
apps/web/entities   # доменные сущности (типы + отображение данных)
apps/web/shared     # переиспользуемая база (ui/lib/api/types)
```

### 2.1) Направление импортов (критично)

Импортируем только “вниз”. Запрещено тянуть зависимости вверх по слоям.
```
app      -> widgets, features, entities, shared
widgets  -> features, entities, shared
features -> entities, shared
entities -> shared
shared   -> только внешние пакеты
```

### 2.2) Public API: импорт только из корня слайса

В каждом слайсе должен быть `index.ts`, который экспортирует только публичный интерфейс.

```ts
// ✅ правильно
import { PostCard } from "@/entities/Post";

// ❌ неправильно (импорт внутренностей)
import { PostCard } from "@/entities/Post/ui/PostCard";
```

Правило: если вам “хочется” импортировать внутренний файл — значит, публичный API слайса неполный (добавьте экспорт в `index.ts`).

### 2.3) Именование папок слайсов

Проектно-устойчивый стандарт (чтобы код выглядел единообразно):
- слой: `lowercase` (`shared`, `widgets`, `entities`)
- слайс/виджет/сущность: `PascalCase` (как имя экспортируемого компонента/модуля), например `widgets/Hero`, `entities/Post`
- “технические” директории внутри слайса: `lowercase` (`ui`, `model`, `lib`, `api`, `types`)

## 3) Модули, компоненты и ответственность

### 3.1) `app/` (Next.js)
- минимум логики: получить данные, собрать страницу из виджетов
- страницы/лейауты могут быть `default export` (требование Next.js)
- вне `app/` по умолчанию используем `named export`

### 3.2) `widgets/`
- “готовые секции” страниц, которые можно переиспользовать
- собирают `entities` + `features` + `shared/ui`
- бизнес-логика и доступ к CMS не живут внутри JSX виджета (см. раздел про data layer)

### 3.3) `entities/`
- типы домена + компоненты отображения данных (Card/Preview и т.п.)
- без “действий пользователя” (это `features`) и без композиции страницы (это `widgets`)

### 3.4) `shared/`
- переносимая база: UI-примитивы, утилиты, типы, data layer, конфиги
- без доменной логики конкретных сущностей

## 4) Data layer и работа со Strapi

Цель: в проекте должен быть понятный “единственный” слой получения данных, а не `fetch()` в случайных компонентах.

Рекомендованный паттерн:
- `apps/web/shared/api/*` — функции получения данных (Strapi + fallback), типы контрактов
- страницы в `app/` вызывают data layer и маппят данные в props виджетов

Правила:
- не вызывать Strapi напрямую из `widgets/*` и `shared/ui/*`
- не тянуть “сырой” Strapi-ответ в UI: приводим к view-модели в data layer или в `app/`
- настройки кэша (`revalidate`, `tags`) должны быть явными и единообразными

## 5) Константы, конфиг и “магические” значения

### 5.1) Три уровня констант

1) **Локальные** (только для файла)
- держим рядом с использованием
- `camelCase`/`PascalCase` по месту

2) **Внутри слайса**
- выносим внутрь слайса (например, `model/constants.ts` или `lib/constants.ts`)
- экспортируем через `index.ts` слайса при необходимости

3) **Общие для проекта**
- `apps/web/shared/lib/*` — чистые константы/хелперы без окружения
- `apps/web/shared/api/*` — константы/хелперы, связанные с данными/контрактами
- `apps/web/app/globals.css` — дизайн-токены (цвета/радиусы/тени/spacing)

### 5.2) Именование констант

- Экспортируемые “данные/таблицы/списки” как константы: `SCREAMING_SNAKE_CASE`
  - пример: `BLOG_RUBRICS`
- Внутренние локальные константы: обычный `camelCase`
  - пример: `defaultRevalidate`, `isDev`

### 5.3) Константы + типы: `as const` и type guards

```ts
export const BLOG_RUBRICS = [
  { title: "Новости", slug: "news", order: 10 },
] as const;

export type BlogRubricSlug = (typeof BLOG_RUBRICS)[number]["slug"];

export function isBlogRubricSlug(value: unknown): value is BlogRubricSlug {
  return BLOG_RUBRICS.some((r) => r.slug === value);
}
```

### 5.4) Окружение (`process.env`)

Правила:
- не читать env-переменные “по всему проекту”
- читаем env в одном месте (data layer / config-модуль) и валидируем
- если переменная обязательна, лучше падать с понятной ошибкой (а не “молча работать неправильно”)

## 6) Нейминг и стиль кода

### 6.1) Файлы и экспорты
- React-компоненты: `PascalCase.tsx`, `named export`
- утилиты: `kebab-case.ts` для многословных (например `blog-rubrics.ts`)
- `index.ts` в слайсе: только public API (экспорты), без логики

### 6.2) Типы
- `PascalCase` для типов/интерфейсов
- Props: `ComponentNameProps`
- события/коллбеки: `onSubmit`, `onChange` (в пропсах); `handleSubmit` (внутри компонента)

### 6.3) Переменные
- boolean: `is*`, `has*`, `can*`, `should*`
- коллекции: во множественном числе (`posts`, `items`)
- функции: глагол + объект (`fetchNewsArticles`, `buildBlogHref`, `makeExcerpt`)

### 6.4) Импорты
Стандартный порядок:
1) `react`, `next/*`
2) third-party
3) внутренние `@/*`
4) относительные
5) типы (`import type ...`) в конце

## 7) TypeScript: базовые правила

Минимальный набор:
- `strict: true` уже включён; не обходить его “силой”
- избегать `any` (если неизвестно — `unknown` + type guard)
- не использовать `as Type` без валидации данных
- по возможности использовать `satisfies` для конфигов/маппингов
- `import type` для типов (чтобы не тянуть лишний рантайм)

## 8) Next.js/React: практики

### 8.1) Server Components по умолчанию
- `'use client'` только когда нужно: state/effect/browser APIs
- маркетинговые страницы держим максимально SSR/Server, минимально гидрируем

### 8.2) Изображения и перфоманс
- `next/image` вместо `<img>` (явные размеры/`sizes`, `priority` только для above-the-fold)
- избегаем layout shift (CLS): резервируем размеры, не “прыгаем” шрифтами

### 8.3) Опасные места
- `dangerouslySetInnerHTML` допускается только для доверенного контента CMS и в строго ограниченном месте (например, тело статьи). Не используем для “конструкции UI”.

## 9) Стили: Tailwind + дизайн-токены

Правила:
- без inline-styles (в JSX) — используем Tailwind-классы или CSS vars
- новые цвета/радиусы/тени добавляем в токены (`apps/web/app/globals.css`), а не размазываем hex по компонентам
- классы объединяем через `cn()` (см. `apps/web/shared/lib/cn.ts`)

## 10) A11y/SEO: Definition of Done

Для каждой страницы/секции:
- семантика: корректные `h1 → h2 → h3`, `nav/main/section`, `button` vs `a`
- доступность: видимый `:focus-visible`, клавиатурная навигация, подписи к полям
- контраст и читаемость
- SEO: title/description, OG для статей/страниц где нужно

## 11) Запрещено (коротко)

- импортировать “вверх” по слоям или из внутренних файлов вместо `index.ts`
- вызывать Strapi/fetch из UI-компонентов (виджетов/примитивов)
- хранить доменную/прикладную логику в `shared/ui`
- коммитить `.env*`/секреты в репозиторий
- делать “god component” на 500+ строк без очевидной причины

## 12) Strapi (apps/cms): практики модели контента

- Схемы Strapi считаем API-контрактом: изменения согласуем с фронтендом.
- Стабильные `slug`: lowercase + `-`, без спонтанных переименований.
- Для страниц и материалов: минимум SEO-поля (title/description/ogImage, optional canonical/noindex).
- Повторяющиеся блоки оформляем Strapi components (hero/faq/stats/timeline и т.п.), а не копированием полей.
